Excelente\! OK recebido.

Com base na nossa conversa e em toda a análise, preparei o código completo para o frontend do seu gerenciador de bots. Este código é uma aplicação React completa e autocontida em um único arquivo HTML.

**Para utilizar, basta seguir estes passos:**

1.  Copie todo o código abaixo.
2.  Cole-o em um novo arquivo de texto.
3.  Salve o arquivo com a extensão `.html` (por exemplo, `index.html`).
4.  Abra este arquivo em seu navegador de internet (como Google Chrome ou Firefox).

A aplicação se conectará ao seu backend, que deve estar rodando e acessível.

-----

### Código Completo do Frontend

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gerenciador de Bots - Telegram</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-router-dom@6/umd/react-router-dom.development.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://unpkg.com/reactflow@11.10.1/dist/umd/index.js"></script>
    <script src="https://unpkg.com/@chakra-ui/react@2.8.2/dist/chakra-ui-react.umd.js"></script>
    <script src="https://unpkg.com/react-icons/lib/umd/index.js"></script>
    
    <link rel="stylesheet" href="https://unpkg.com/reactflow@11.10.1/dist/style.css" />
    <style>
      /* Estilos Globais */
      body { margin: 0; font-family: sans-serif; background-color: #1A202C; }
      /* Correções de Estilo para o ReactFlow */
      .react-flow__handle { opacity: 0.5; }
      .react-flow__handle:hover { opacity: 1; }
      .react-flow__node {
        border-radius: 8px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        border: 1px solid #4A5568;
        background-color: #2D3748;
        color: white;
      }
       .react-flow__node.selected {
        box-shadow: 0 0 0 2px #3182CE;
      }
      .react-flow__edge-path {
        stroke-width: 2;
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Desestruturação para fácil acesso
        const { ChakraProvider, Box, Button, Input, Text, Heading, VStack, HStack, Spinner, useToast, Modal, ModalOverlay, ModalContent, ModalHeader, ModalFooter, ModalBody, ModalCloseButton, Select, Textarea, NumberInput, NumberInputField, Switch, FormControl, FormLabel, Tag, useDisclosure } = ChakraUI;
        const { MemoryRouter, Routes, Route, Link, useNavigate, useParams, Navigate } = ReactRouterDOM;
        const { useState, useEffect, useCallback, createContext, useContext, useMemo } = React;
        const { ReactFlowProvider, useNodesState, useEdgesState, addEdge, Background, Controls, MiniMap, Handle, Position } = ReactFlow;
        const { FiMessageSquare, FiSend, FiBot, FiGitBranch, FiLogIn, FiLogOut, FiSettings, FiPlayCircle, FiBarChart2 } = ReactIcons.Fi;

        // ===== CONTEXTO DE AUTENTICAÇÃO =====
        const AuthContext = createContext(null);

        const AuthProvider = ({ children }) => {
            const [token, setToken] = useState(localStorage.getItem('authToken'));
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);
            const navigate = useNavigate();

            axios.defaults.baseURL = 'http://localhost:3001/api'; // Mude a URL base se o seu backend rodar em outra porta/endereço

            useEffect(() => {
                if (token) {
                    localStorage.setItem('authToken', token);
                    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
                    // Aqui você poderia ter um endpoint para buscar dados do usuário
                    // Ex: axios.get('/sellers/me').then(res => setUser(res.data))...
                } else {
                    localStorage.removeItem('authToken');
                    delete axios.defaults.headers.common['Authorization'];
                }
                setLoading(false);
            }, [token]);

            const login = async (email, password) => {
                const response = await axios.post('/sellers/login', { email, password });
                setToken(response.data.token);
                setUser(response.data.seller);
                navigate('/');
            };
            
            const register = async (name, email, password) => {
                await axios.post('/sellers/register', { name, email, password });
                // Após o registro, faz o login automaticamente
                await login(email, password);
            };

            const logout = () => {
                setToken(null);
                setUser(null);
                navigate('/login');
            };

            const value = { token, user, login, register, logout };

            return (
                <AuthContext.Provider value={value}>
                    {!loading && children}
                </AuthContext.Provider>
            );
        };

        const useAuth = () => useContext(AuthContext);

        const ProtectedRoute = ({ children }) => {
            const { token } = useAuth();
            if (!token) {
                return <Navigate to="/login" />;
            }
            return children;
        };
        
        // ===== COMPONENTES DE UI =====
        const Sidebar = () => {
            const { logout } = useAuth();

            const SidebarButton = ({ icon, children, to }) => (
              <Link to={to}>
                <Button 
                    leftIcon={icon} 
                    justifyContent="start" 
                    w="100%" 
                    variant="ghost"
                    _hover={{ bg: 'gray.600' }}
                >
                    {children}
                </Button>
              </Link>
            );

            return (
                <VStack 
                    as="nav" 
                    p={4} 
                    spacing={4} 
                    align="stretch" 
                    bg="gray.800"
                    color="white"
                    h="100vh"
                    w="250px"
                    borderRight="1px"
                    borderColor="gray.700"
                >
                    <Heading size="md" textAlign="center" mb={6}>Bot Manager</Heading>
                    <SidebarButton icon={<FiBarChart2 />} to="/">Dashboard</SidebarButton>
                    <SidebarButton icon={<FiBot />} to="/bots">Bots</SidebarButton>
                    <SidebarButton icon={<FiGitBranch />} to="/flows">Fluxos</SidebarButton>
                    <SidebarButton icon={<FiSend />} to="/dispatches">Disparos</SidebarButton>
                    <SidebarButton icon={<FiMessageSquare />} to="/live-chat">Chat ao Vivo</SidebarButton>
                    <Box flex={1} />
                    <Button leftIcon={<FiLogOut />} onClick={logout} colorScheme="red">Sair</Button>
                </VStack>
            );
        }

        const MainLayout = ({ children }) => (
            <HStack align="start" spacing={0}>
                <Sidebar />
                <Box as="main" p={8} w="calc(100% - 250px)" h="100vh" overflowY="auto">
                    {children}
                </Box>
            </HStack>
        );

        // ===== PÁGINAS =====
        
        const LoginPage = () => {
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [name, setName] = useState('');
            const [loading, setLoading] = useState(false);
            const { login, register } = useAuth();
            const toast = useToast();

            const handleSubmit = async (e) => {
              e.preventDefault();
              setLoading(true);
              try {
                if (isLogin) {
                  await login(email, password);
                } else {
                  await register(name, email, password);
                }
              } catch (error) {
                toast({
                  title: "Erro",
                  description: error.response?.data?.message || "Ocorreu um erro.",
                  status: "error",
                  duration: 5000,
                  isClosable: true,
                });
              } finally {
                setLoading(false);
              }
            };
            
            return (
                <VStack h="100vh" justify="center" align="center" bg="gray.800">
                    <VStack as="form" onSubmit={handleSubmit} spacing={4} p={8} bg="gray.700" color="white" borderRadius="md" boxShadow="lg" minW="400px">
                        <Heading>{isLogin ? "Login" : "Cadastro"}</Heading>
                        {!isLogin && (
                          <Input placeholder="Nome" value={name} onChange={(e) => setName(e.target.value)} isRequired />
                        )}
                        <Input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} isRequired />
                        <Input type="password" placeholder="Senha" value={password} onChange={(e) => setPassword(e.target.value)} isRequired />
                        <Button type="submit" isLoading={loading} colorScheme="blue" w="100%">{isLogin ? "Entrar" : "Cadastrar"}</Button>
                        <Button variant="link" onClick={() => setIsLogin(!isLogin)}>{isLogin ? "Não tem uma conta? Cadastre-se" : "Já tem uma conta? Faça login"}</Button>
                    </VStack>
                </VStack>
            );
        };
        
        const DashboardPage = () => <Heading color="white">Dashboard</Heading>;
        
        const BotsPage = () => {
          const [bots, setBots] = useState([]);
          const [botName, setBotName] = useState('');
          const [botToken, setBotToken] = useState('');
          const [loading, setLoading] = useState(true);
          const { isOpen, onOpen, onClose } = useDisclosure();
          const toast = useToast();
          
          const fetchBots = async () => {
              try {
                  const response = await axios.get('/dashboard/data');
                  setBots(response.data.bots);
              } catch (error) {
                  toast({ title: "Erro ao buscar bots", status: "error" });
              } finally {
                  setLoading(false);
              }
          };

          useEffect(() => {
              fetchBots();
          }, []);

          const handleAddBot = async () => {
              try {
                  // O backend espera apenas o nome, o token é salvo depois
                  await axios.post('/bots', { bot_name: botName });
                  toast({ title: "Bot adicionado!", status: "success" });
                  onClose();
                  fetchBots();
                  setBotName('');
              } catch (error) {
                  toast({ title: "Erro ao adicionar bot", description: error.response?.data?.message, status: "error" });
              }
          };
          
          const handleDeleteBot = async (id) => {
              try {
                  await axios.delete(`/bots/${id}`);
                  toast({ title: "Bot removido!", status: "success" });
                  fetchBots();
              } catch (error) {
                  toast({ title: "Erro ao remover bot", status: "error" });
              }
          }
          
          if(loading) return <Spinner color="white" />;

          return (
              <VStack align="start" spacing={6}>
                  <HStack w="100%" justify="space-between">
                      <Heading color="white">Meus Bots</Heading>
                      <Button colorScheme="blue" onClick={onOpen}>Adicionar Bot</Button>
                  </HStack>
                  
                  {bots.length > 0 ? bots.map(bot => (
                      <HStack key={bot.id} p={4} bg="gray.700" borderRadius="md" w="100%" justify="space-between">
                          <Text color="white">{bot.bot_name}</Text>
                          <Text color="gray.400">Token: {bot.bot_token ? '**********' : 'Não configurado'}</Text>
                          <Button colorScheme="red" size="sm" onClick={() => handleDeleteBot(bot.id)}>Remover</Button>
                      </HStack>
                  )) : (
                      <Text color="gray.400">Nenhum bot cadastrado ainda.</Text>
                  )}

                  <Modal isOpen={isOpen} onClose={onClose}>
                      <ModalOverlay />
                      <ModalContent bg="gray.700" color="white">
                          <ModalHeader>Adicionar Novo Bot</ModalHeader>
                          <ModalCloseButton />
                          <ModalBody>
                              <Input placeholder="Nome do Bot (Ex: Vendas Bot)" value={botName} onChange={e => setBotName(e.target.value)} />
                              <Text fontSize="sm" color="gray.400" mt={2}>Você poderá adicionar o token do Telegram depois.</Text>
                          </ModalBody>
                          <ModalFooter>
                              <Button variant="ghost" mr={3} onClick={onClose}>Cancelar</Button>
                              <Button colorScheme="blue" onClick={handleAddBot}>Salvar</Button>
                          </ModalFooter>
                      </ModalContent>
                  </Modal>
              </VStack>
          );
        };
        
        const FlowsPage = () => {
          const [flows, setFlows] = useState([]);
          const [bots, setBots] = useState([]);
          const [flowName, setFlowName] = useState('');
          const [selectedBot, setSelectedBot] = useState('');
          const [loading, setLoading] = useState(true);
          const { isOpen, onOpen, onClose } = useDisclosure();
          const navigate = useNavigate();
          const toast = useToast();
          
          const fetchFlowsAndBots = async () => {
            try {
              const [flowsRes, botsRes] = await Promise.all([
                  axios.get('/flows'),
                  axios.get('/dashboard/data').then(res => res.data.bots)
              ]);
              setFlows(flowsRes.data);
              setBots(botsRes);
              if (botsRes.length > 0) {
                  setSelectedBot(botsRes[0].id);
              }
            } catch (error) {
              toast({ title: "Erro ao buscar dados", status: "error" });
            } finally {
              setLoading(false);
            }
          };

          useEffect(() => {
            fetchFlowsAndBots();
          }, []);
          
          const handleCreateFlow = async () => {
             if (!flowName || !selectedBot) {
                 toast({ title: "Preencha todos os campos", status: "warning" });
                 return;
             }
             try {
                const response = await axios.post('/flows', { name: flowName, botId: selectedBot });
                toast({ title: "Fluxo criado!", status: "success" });
                navigate(`/flows/edit/${response.data.id}`);
             } catch(error) {
                toast({ title: "Erro ao criar fluxo", status: "error" });
             }
          };
          
          if(loading) return <Spinner color="white" />;
          
          return (
            <VStack align="start" spacing={6}>
              <HStack w="100%" justify="space-between">
                <Heading color="white">Fluxos de Conversa</Heading>
                <Button colorScheme="blue" onClick={onOpen} isDisabled={bots.length === 0}>
                  {bots.length > 0 ? "Criar Novo Fluxo" : "Adicione um bot primeiro"}
                </Button>
              </HStack>

              {flows.length > 0 ? flows.map(flow => (
                <HStack key={flow.id} p={4} bg="gray.700" borderRadius="md" w="100%" justify="space-between">
                    <VStack align="start">
                        <Text color="white" fontWeight="bold">{flow.name}</Text>
                        <Tag size="sm">{bots.find(b => b.id === flow.bot_id)?.bot_name || 'Bot desconhecido'}</Tag>
                    </VStack>
                    <Button colorScheme="green" size="sm" onClick={() => navigate(`/flows/edit/${flow.id}`)}>
                      Editar Fluxo
                    </Button>
                </HStack>
              )) : (
                <Text color="gray.400">Nenhum fluxo criado ainda.</Text>
              )}
              
              <Modal isOpen={isOpen} onClose={onClose}>
                <ModalOverlay />
                <ModalContent bg="gray.700" color="white">
                    <ModalHeader>Criar Novo Fluxo</ModalHeader>
                    <ModalCloseButton />
                    <ModalBody>
                      <VStack spacing={4}>
                        <Input placeholder="Nome do Fluxo (Ex: Boas-vindas)" value={flowName} onChange={e => setFlowName(e.target.value)} />
                        <Select placeholder="Selecione um Bot" value={selectedBot} onChange={e => setSelectedBot(e.target.value)}>
                            {bots.map(bot => <option key={bot.id} value={bot.id} style={{color: 'black'}}>{bot.bot_name}</option>)}
                        </Select>
                      </VStack>
                    </ModalBody>
                    <ModalFooter>
                        <Button variant="ghost" mr={3} onClick={onClose}>Cancelar</Button>
                        <Button colorScheme="blue" onClick={handleCreateFlow}>Criar e Editar</Button>
                    </ModalFooter>
                </ModalContent>
              </Modal>
            </VStack>
          );
        };
        
        // ===== COMPONENTES DO FLOW BUILDER =====

        const initialNodes = [
          { id: '1', type: 'startNode', position: { x: 250, y: 5 }, data: { label: 'Início' } }
        ];

        const nodeTypes = { 
          startNode: ({ data }) => (
            <Box p={4} bg="green.500" borderRadius="md">
              <Text fontWeight="bold">{data.label}</Text>
              <Handle type="source" position={Position.Bottom} />
            </Box>
          ),
          messageNode: ({ id, data }) => (
            <Box p={4} w="300px">
              <Handle type="target" position={Position.Top} id={`in-${id}`} />
              <Text mb={2} fontWeight="bold">Bloco de Mensagens</Text>
              {data.messages.map((msg, index) => (
                <Box key={index} p={2} bg="gray.600" borderRadius="md" mb={2}>
                  <Text fontSize="sm">{msg.type === 'delay' ? `Digitando por ${msg.content}s` : msg.content}</Text>
                </Box>
              ))}
              <Box mt={4} p={2} borderTop="1px" borderColor="gray.600">
                  <HStack justify="space-between">
                    <Text fontSize="xs">SE NÃO RESPONDER</Text>
                    <Handle type="source" position={Position.Right} id={`timeout-${id}`} style={{ top: 'auto', bottom: 25, background: '#E53E3E' }}/>
                  </HStack>
                   <HStack justify="space-between" mt={2}>
                    <Text fontSize="xs">SE RESPONDER</Text>
                    <Handle type="source" position={Position.Right} id={`response-${id}`} style={{ top: 'auto', bottom: 10, background: '#38A169' }}/>
                  </HStack>
              </Box>
            </Box>
          ),
        };
        
        const SidebarFlowBuilder = ({ addNode }) => (
          <Box p={4} bg="gray.800" w="250px" h="100%" borderLeft="1px" borderColor="gray.700">
            <VStack spacing={4}>
              <Button onClick={() => addNode('messageNode')} w="100%">Adicionar Mensagem</Button>
              {/* Adicionar outros tipos de blocos aqui */}
            </VStack>
          </Box>
        );

        let id = 2;
        const getId = () => `${id++}`;

        const FlowBuilderPage = () => {
          const { flowId } = useParams();
          const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
          const [edges, setEdges, onEdgesChange] = useEdgesState([]);
          const [flowName, setFlowName] = useState('Carregando...');
          const [selectedNode, setSelectedNode] = useState(null);
          const toast = useToast();

          useEffect(() => {
              const fetchFlow = async () => {
                  try {
                      // const response = await axios.get(`/flows/${flowId}`); // Seu backend não tem essa rota individual
                      // Simulação até que a rota seja criada:
                      const allFlows = await axios.get('/flows');
                      const currentFlow = allFlows.data.find(f => f.id == flowId);
                      if (currentFlow) {
                          setFlowName(currentFlow.name);
                          // O backend precisa salvar e retornar a estrutura de nós e arestas
                          // if(currentFlow.nodes) setNodes(currentFlow.nodes);
                          // if(currentFlow.edges) setEdges(currentFlow.edges);
                      } else {
                          setFlowName("Fluxo não encontrado");
                      }
                  } catch(e) {
                      toast({title: "Erro ao carregar fluxo", status: "error"});
                      setFlowName("Erro ao carregar");
                  }
              };
              fetchFlow();
          }, [flowId]);

          const onConnect = useCallback((params) => setEdges((eds) => addEdge(params, eds)), [setEdges]);
          
          const onNodeClick = (event, node) => {
              // Simples clique seleciona, não faz mais nada
          };

          const onNodeDoubleClick = (event, node) => {
              setSelectedNode(node);
          };

          const addNode = (type) => {
            const newNode = {
              id: getId(),
              type,
              position: { x: Math.random() * 400, y: Math.random() * 400 },
              data: { messages: [{type: 'text', content: 'Nova mensagem...'}] }
            };
            setNodes((nds) => nds.concat(newNode));
          };

          const updateNodeData = (nodeId, newData) => {
            setNodes((nds) => nds.map(node => {
              if (node.id === nodeId) {
                return { ...node, data: { ...node.data, ...newData } };
              }
              return node;
            }));
          };
          
          const saveFlow = async () => {
              try {
                  await axios.put(`/flows/${flowId}`, {
                      name: flowName,
                      nodes, // O backend precisa aceitar 'nodes' e 'edges'
                      // edges,
                  });
                  toast({title: "Fluxo salvo com sucesso!", status: "success"});
              } catch (e) {
                  toast({title: "Erro ao salvar fluxo", status: "error"});
              }
          };

          return (
            <HStack h="calc(100vh - 64px)" align="start" spacing={0}>
              <Box h="100%" w="100%" bg="gray.900">
                <HStack p={2} bg="gray.800" justify="space-between">
                    <Input value={flowName} onChange={e => setFlowName(e.target.value)} w="300px" color="white" />
                    <Button colorScheme="blue" onClick={saveFlow}>Salvar Fluxo</Button>
                </HStack>
                <ReactFlow
                  nodes={nodes}
                  edges={edges}
                  onNodesChange={onNodesChange}
                  onEdgesChange={onEdgesChange}
                  onConnect={onConnect}
                  onNodeClick={onNodeClick}
                  onNodeDoubleClick={onNodeDoubleClick}
                  nodeTypes={nodeTypes}
                  fitView
                >
                  <Background />
                  <Controls />
                  <MiniMap />
                </ReactFlow>
              </Box>
              {selectedNode ? (
                 <Box p={4} bg="gray.800" w="350px" h="100%" borderLeft="1px" borderColor="gray.700">
                    <Button onClick={() => setSelectedNode(null)} size="sm" mb={4}>Voltar</Button>
                    <Heading size="md" mb={4}>Editando Bloco</Heading>
                    {/* Renderiza o painel de edição correto */}
                 </Box>
              ) : (
                <SidebarFlowBuilder addNode={addNode} />
              )}
            </HStack>
          );
        };
        
        const DispatchesPage = () => <Heading color="white">Disparos em Massa</Heading>;
        const LiveChatPage = () => <Heading color="white">Chat ao Vivo</Heading>;
        
        // ===== APLICAÇÃO PRINCIPAL =====
        function App() {
            return (
                <ChakraProvider>
                  <MemoryRouter>
                    <AuthProvider>
                        <Routes>
                            <Route path="/login" element={<LoginPage />} />
                            <Route path="/*" element={
                                <ProtectedRoute>
                                    <MainLayout>
                                        <Routes>
                                            <Route path="/" element={<DashboardPage />} />
                                            <Route path="/bots" element={<BotsPage />} />
                                            <Route path="/flows" element={<FlowsPage />} />
                                            <Route 
                                              path="/flows/edit/:flowId" 
                                              element={
                                                <ReactFlowProvider>
                                                  <FlowBuilderPage />
                                                </ReactFlowProvider>
                                              } 
                                            />
                                            <Route path="/dispatches" element={<DispatchesPage />} />
                                            <Route path="/live-chat" element={<LiveChatPage />} />
                                        </Routes>
                                    </MainLayout>
                                </ProtectedRoute>
                            } />
                        </Routes>
                    </AuthProvider>
                  </MemoryRouter>
                </ChakraProvider>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
```
